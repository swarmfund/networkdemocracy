\documentclass[submission, copyright,creativecommons,sharealike,noncommercial]{eptcs}
\providecommand{\event}{Swarm group}

\newcommand{\yourpath}{Preambles/}
\usepackage{import}
\usepackage{eufrak}
\subimport{\yourpath/}{packages}
\subimport{\yourpath/}{macros}
\subimport{\yourpath/}{tikzstyles}

\subimport{Preambles/}{LocalDefinitions}


\title{Delegated Range Voting with Tokens and Shit}
\author{Fabrizio Romano Genovese
	\institute{Swarm Team}
	\institute{Quantum Group \\ University of Oxford}
	\email{fabrizio@swarm.fund}
\and
Jelle Herold
	\institute{Swarm Team}
	\email{jelle@swarm.fund}
}
\def\titlerunning{Liquid Democracy -- Concrete proposal}
\def\authorrunning{F.R.Genovese \& J. Herold}


\begin{document}

%	\bibliographystyle{eptcs}
	
	\maketitle

	\begin{abstract}
		After some brainstorming sessions in which the main ideas have been laid down, we start drafting how a hypothetical Liquid Democracy implementation for Swarm could look in technical terms. We will use a typed approach, that should in principle be compatible with the concepts behind StateBox.
	\end{abstract}

\section{Why voting with tokens as it is is not a good idea}
	The standard voting with tokens works like this: Everyone obtains some voting tokens in some way (for instance, one receives an amount of voting tokens equal to the tokens owned). These tokens then get sent to an address that fundamentally means ``yes'' or ``no''. Tokens sent in any address are then counted and a decision is made. This has three fundamental problems:
	\begin{enumerate}
		\item This voting procedure is basically majority voting, that is super flawed.
		\item In the very same moment someone votes, the tokens are transferred to the other address and can be publicly seen. This means that a sufficiently skilled user is able to see in real time who is winning the vote. This is very bad because gives away data useful for any kind of manipulation.
		\item If a voter sends his ``real'' tokens to someone else, he retains his voting tokens. This means that the other person receiving the tokens has no voting power whatsoever. On the other hand, the person retaining the voting tokens has less or no stake at all.
		
		For instance, someone with a lot of real tokens could sell them all, and then use the voting tokens he retained to vote for a very bad decision for the platform. At this point the tokens he just sold will be depreciated because of this bad decision and the person will be able to buy them back at a fraction of the price, making a profit. This means that a very powerful user on the platform can exploit the democratic infrastructure to make direct profits.
		
		\item Delegation can be a mess.
	\end{enumerate}

\section{A fix for this shit}
	As I argued multiple times, a fix for point 1 is adopting other voting procedures, such as range voting. We will then try to understand how to implement range voting with a tokens-and-shit approach.
	
	I am giving for granted that you know how range voting works. If you don't, read about it on the other PDF or on Wikipedia. As an alternative, just fuck yourself.
	
	\begin{definition}\label{voting string}
		Suppose we have a set $\mathcal{N}$ of candidates. Suppose moreover we have a set $\mathfrak{M}$ of possible voting values. For instance, if we have three people proposing (call them $A, B, C$) and the user can rate every one of these people from $-3$ to $-3$, then $\mathcal{N} := \{A, B, C\}$ and $\mathfrak{M} := \{-3,-2,-1,0,1,2,3\}$, hence $|\mathcal{N}| = 3$ and $|\mathfrak{M}|=7$.
		
		We can express the voting of a user as a string $(a,b,c)$, where $a,b,c \in \mathfrak{M}$. $a$ represents the rating given to candidate $A$, $b$ the rating given to candidate $B$ and $c$ the rating given to candidate $C$. This string is called \emph{voting string}.
	\end{definition}
	\begin{definition}
 		We denote an user $A$ delegating his/her vote to a user $B$ with $A \to B$.
	\end{definition}
	
	\subsection{The algorythm}
		Here we draft an algorythm to take care of voting. An analysis of this algorythm will be given in the next section.
		\subsubsection{Phase 1: Submitting candidatures}
		
		\begin{itemize}
			\item A contract called $\textbf{CANDIDATES}$ is created. This contract determines from when to when voting is open and is fundamentally a list of strings representing the candidates;
			
			\item An user that wants to run for the election writes a bio and a covering letter and he signs this with his/eth ethwallet private key.
			
			\item The user adds to a public contract a line like this:
			\[
			(\text{ethwallet} \mid \text{hash of the bio} \mid \text{hash of the covering letter})
			\]
			
			\item When the window closes, every new submission is rejected. 
		\end{itemize}


		\subsubsection{Phase 0: Submitting token vesting parameters}
			All bought tokens are vested according to a function described in the
			whitepaper. This function takes two parameters and for each
			there is a given set of allowed values with size $< 6$, say.

			\begin{itemize}
			\item number of periods, taken from $X$
			\item days per period, taken from $Y$
			\end{itemize}


			We set $\mathcal{N}$ to all $|X|\cdot|Y|$ possible pairs
			$\langle x_i, y_j \rangle \elem X \times Y$ and
			$|\mathfrak{M}|=7$, say.

			The UI shows all these pairs as a matrix $A=v^i_j$
			and the user clicks on their preference.

			We then apply a function $f: X \times Y \to A$ to
			some vote $(x,y)$ which computes some ``gradient''
			focussed around the vote, for example distance:

			\[
			v^i_j \mapsto round(3 - min(7, c*(abs(x-i)^d * abs(y-j)^d)))
			\]
			(Might also use $+$, or distance to target duration $x*y$).

			The two parameters $c$ and $d$ can be used to encode the
			shape over the vode.  We can encode a vote as a number of
			applications of this function to the matrix.

		\subsubsection{Guardians and private keys}
			\begin{itemize}
				\item A public key is created out of two secret keys, that will be kept by two different trusted parties (us and the tokensale guys, for instance);
				
				\item The public key is denoted with $pub$, while the secret keys are denoted with $sec_1$ and $sec_2$, respectively. It makes sense to give one of these secret keys to the Estonian non-profit organization that oversees Swarm, if possible.
			\end{itemize}

		\subsubsection{Voting and some issues}
			If we use the Shamir secret sharing scheme, there is the
			assumption of having a trusted ``dealer'',
			the party generating and handling out $sec_i$.

			Voting itself is done by sending a transaction from a
			wallet. The balance in the wallet is used to weight the
			vote.

			Therefor, wallets on an exchange preclude the owner from
			voting as the exchange holds the private key. Instead the
			exchange can vote with the users swarm.

			The vote data itself has to be encrypted. The contract
			cannot check if the data is correct but has to accept
			it at face value (basic prefix check could be performed).

		\subsubsection{Voting window}
			\begin{itemize}
				\item Every person owning an eth wallet (even with no swarm tokens in it) can submit a vote. Every user can see who are the candidates running on our dedicated website. The website just displays the addresses of all the candidates along with their bios and covering letters, ordered by their stake. The fact that $\textbf{CANDIDATES}$ contains this information ensures that we are not providing incorrect/manipulated information about the candidates.
				
				\item An eth contract, called $\textbf{VOTE}$, is created on the blockchain. This contract determines from when to when voting is open and is fundamentally a list of strings representing the users votes.
				
				\item The user vote is a string defined as follows: 
				\[
				(\text{user wallet address}, \text{voting string}, \text{delegation address})
				\]
				Where:
				\begin{description}
					\item[user wallet address] is the eth address of the voter;
					\item[voting string] is a string defined as in Definition~\ref{voting string}, where $\mathfrak{M}$ is the set of all the addresses in \textbf{CANDIDATES}. To be specific, the first entry of the voting string refers to the first candidate in $\textbf{CANDIDATES}$, the second to the second candidate in \textbf{CANDIDATES} and so on.
					
					\item[delegation address] is an eth address.
					
					\item vote strings and delegation addresses are set to some standard value ($0$ for eth address) and $(0,0, \dots, 0)$ for the vote string) if the user does not specify any value.
				\end{description}
			
				\item The user encrypts this string using $pub$ and adds the line to $\textbf{VOTE}$.
			\end{itemize}
		
		\subsubsection{Outcome}
			\begin{itemize}
				\item When the voting window closes, the outcome of the vote is calculated. The secret keys $sec_1$ and $sec_2$ are made public and added to $\textbf{VOTE}$. With this information, any user can decrypt the content of $\textbf{VOTE}$.
				
				\item The outcome is calculated as follows: First, we decrypt $\textbf{VOTE}$ and we copy its content to $\textbf{VOTE'}$. $\textbf{VOTE'}$ is basically a huge database with all the addresses of people who voted, their voting preference and the delegation address specified. 
				
				\item We check that no one used the Swarm foundation address to vote. Since the foundation owns like 33\% of the total swarm tokens, this would be very unfair: Partners can of course vote with their personal wallets but not with the foundation one. Hardcoding this guarantees transparency both for the partners and for the investors.
				
				We scroll $\textbf{VOTE'}$ and check the first address of each string. If a string starting with the Swarm foundation eth address is found, we erase it. We keep doing this until we reach the bottom of the contract. 
				
				\item After this, we have to check that people did not vote two times. This is easy: We scroll the $\textbf{VOTE'}$ database again and check the first address of each string (voter's address). If two or more strings have the same voting address, only the most recent is kept. Since strings are added as votes come, we just have to erase all but the bottommost one.
			
				\item Then we check that all the delegations are correct. This means we have to rule out cases in which there are delegation loops, i.e. we have to deal with situations like $A \to B \to C \to A$ where we have a loop and it is not clear who is voting on behalf of who. To do this we apply the following algorithm:
				
				\begin{itemize}
					\item Call $a,b,\dots$ the entries in $\textbf{VOTE'}$. Starting from $a$, we form a string called \emph{check} as follows:
					\begin{itemize}
						\item The first entry of \emph{check} is $a[1]$ (user wallet address).
				
						\item The next entry of \emph{check} is $a[3]$ (the delegation address).
				
						\item If $a[3]=0$ then the algorithm terminates and we run it on the next entry in $\textbf{VOTE'}$. Otherwise we scroll down \textbf{VOTE'} until we find an entry $n$ such that $n[1] = a[3]$ (we check if the delegated address has voted). If this string does not exists, we then modify \textbf{VOTE'} setting $a[3] = 0$ (delegation is not valid). If it exists, we add $n[1]$ to \emph{check}.
						
						\item We re-run the same procedure starting from $n[1]$.
						
						\item At every step, we check if \emph{check} has repeated entries. Two things can happen:
						
						\begin{itemize}
							\item If we find that repeated entries, then \emph{check} will look like $(a,b,x,c,d, \dots, f, x)$. In this case we modify \textbf{VOTE'} setting $x[3] = c[3] = \dots = f[3] = 0$ (we eliminate the loop setting all the delegations in the loop as not valid); 
							then we start again using the string immediately following $a$.
							
							\item If we don't find repeated entries, we eventually reach the end of \textbf{VOTE'}. In this case we start again using the string immediately following $a$.
						\end{itemize} 
					\end{itemize}
				
				\item At the end of this process, \textbf{VOTE'} will be free of delegation loops. At this point we calculate the outcome as follows:
					\begin{itemize}
						\item For every string $n$ we check that $n[2]$ is a valid voting string, meaning that all the points assigned are in the correct range and the number of entries in the string equals the number of candidates. Mathematically, this means that every entry in $n[2]$ is in $\mathfrak{M}$ and that the lenght of $n$ is $|\mathcal{N}|$. If this is not the case we set $n[2]$ to the string made of $|\mathcal{N}|$ entries in which every entry is $0$. We will denote this string just with $\mathbf{0}$.
					
						\item For every string $n$, call $\sigma_{n[1]}$ the stake of $n[1]$. If $n[3] = 0$ (no delegation), then $n[2] = \sigma_{n[1]} n[2]$, meaning that we multiply every entry of $n[2]$ by $\sigma_{n[1]}$. If $n[3] = a$, then $n[2] = \mathbf{0}$ and $\sigma_{k[1]} = \sigma_{n[1]} + \sigma_{k[1]}$ (we transfer the stake to the delegated user), where $k$ is the entry such that $k[1] = a$ (having eliminated loops there is only one such string $k$).
						
						
						\item We calculate the string \emph{outcome} as $\sum_{n \in \textbf{VOTE}} n[2]$ (we are summing all the points in all the voting strings componentwise).
						
						\item The elected candidates are the ones with the highest amount of points in \emph{outcome}. For instance, if $\emph{outcome} = (234, 152, 36)$ then the candidate corresponding to the first string entry is the winner.
						
						\item We have to elect three candidates for the board. We proceed as follows: We consider the three candidates having the biggest amount of points. If these are more than three, we further order them considering their stake, meaning that if $A,B$ have the same amount of points but the stake of $A$ is bigger than the stake of $B$, then $A$ is preferred. If we still have more than three candidates ex-aequo, then we randomly chose three.
					\end{itemize}
				\end{itemize}
			\end{itemize}

	\subsection{Analysis}
		With this algorithm we solve a shitload or problems. No one is able to see who voted for who and what is the delegation structure until the vote ends. The fact that the public key is obtained from two different secret keys means that not even the guardians are able to do this alone. The guardians should agree to fuck the platform sharing their secret keys and accessing the votes outcome while the voting window is still open. This is obviously possible and this is why the guardians should be two trusted and independent entities.
		
		Users are able to delegate their vote to someone. If this delegation doesn't work well (loops, the delegate didn't vote) then the system falls back on the user preference. This means that if your delegate is a dickhead your vote is not wasted.
		
		Since the stake is taken to be the one at the closing of the voting window, people cannot really fiddle with their token in the hope to increase their voting stake. Moreover, the voting is not made sending tokens to this or that address, and no tokens are locked in the process, so everyone can move his/her tokens as he/she pleases during a voting. The only thing to keep in mind is that your stake will be the one at the end of the closing window.
		
		
\end{document}


